package retrobus.library.board

import chisel3._
import circt.stage.ChiselStage
import java.io.{File, PrintWriter}

/**
 * Custom Chisel elaborator that generates Alchitry constraint files
 * alongside the Verilog output.
 */
object AlchitryElaborator {
  
  /**
   * Pin mapping configuration
   */
  case class PinMapping(
    port: String,
    virtualPin: String,
    ioStandard: String = "LVCMOS33",
    pullup: Boolean = false,
    pulldown: Boolean = false,
    drive: Option[Int] = None,
    slew: Option[String] = None
  )
  
  /**
   * Elaborate a Chisel module with Alchitry pin constraints
   */
  def elaborate[T <: Module](
    gen: => T,
    pinMappings: Seq[PinMapping],
    board: String = "au",
    targetDir: String = "generated",
    moduleName: Option[String] = None
  ): Unit = {
    
    // Create target directory
    new File(targetDir).mkdirs()
    
    // Run Chisel elaboration
    val stage = new ChiselStage
    val annotations = stage.execute(
      Array("--target-dir", targetDir),
      Seq(chisel3.stage.ChiselGeneratorAnnotation(() => gen))
    )
    
    // Extract module name
    val topModule = moduleName.getOrElse {
      annotations.collectFirst {
        case firrtl.stage.FirrtlCircuitAnnotation(circuit) => circuit.main
      }.getOrElse("Top")
    }
    
    // Generate constraint file
    generateConstraintFile(topModule, pinMappings, board, s"$targetDir/$topModule.xdc")
    
    // Generate TCL script for Vivado
    generateTclScript(topModule, board, targetDir)
    
    // Generate pin report
    generatePinReport(pinMappings, board, s"$targetDir/${topModule}_pins.txt")
    
    println(s"Elaboration complete!")
    println(s"  Verilog: $targetDir/$topModule.sv")
    println(s"  Constraints: $targetDir/$topModule.xdc")
    println(s"  TCL Script: $targetDir/build_$topModule.tcl")
    println(s"  Pin Report: $targetDir/${topModule}_pins.txt")
  }
  
  /**
   * Generate XDC constraint file
   */
  private def generateConstraintFile(
    moduleName: String,
    pinMappings: Seq[PinMapping],
    board: String,
    outputFile: String
  ): Unit = {
    val writer = new PrintWriter(outputFile)
    
    try {
      writer.println(s"# $moduleName Constraint File")
      writer.println(s"# Board: Alchitry ${board.toUpperCase}")
      writer.println(s"# Generated by AlchitryElaborator")
      writer.println(s"# Date: ${java.time.LocalDateTime.now}")
      writer.println()
      
      // Standard clock constraint
      pinMappings.find(_.port.toLowerCase.contains("clk")).foreach { clkPin =>
        val realPin = AlchitryPinMapper.getRealPin(clkPin.virtualPin, board)
        writer.println("# Clock Configuration")
        writer.println(s"set_property PACKAGE_PIN $realPin [get_ports ${clkPin.port}]")
        writer.println(s"set_property IOSTANDARD ${clkPin.ioStandard} [get_ports ${clkPin.port}]")
        writer.println(s"create_clock -period 10.000 -name ${clkPin.port} [get_ports ${clkPin.port}]")
        writer.println()
      }
      
      // Group pins by type
      val groups = pinMappings.groupBy { pin =>
        if (pin.port.contains("clk")) "Clock"
        else if (pin.port.contains("rst")) "Reset"
        else if (pin.port.contains("led")) "LEDs"
        else if (pin.port.contains("addr")) "Address Bus"
        else if (pin.port.contains("data")) "Data Bus"
        else "Other I/O"
      }
      
      groups.foreach { case (groupName, pins) =>
        if (groupName != "Clock") {  // Clock already handled
          writer.println(s"# $groupName")
          pins.foreach { pin =>
            val realPin = AlchitryPinMapper.getRealPin(pin.virtualPin, board)
            
            // Package pin
            writer.println(s"set_property PACKAGE_PIN $realPin [get_ports ${pin.port}]")
            
            // IO Standard
            writer.println(s"set_property IOSTANDARD ${pin.ioStandard} [get_ports ${pin.port}]")
            
            // Optional properties
            if (pin.pullup) {
              writer.println(s"set_property PULLUP TRUE [get_ports ${pin.port}]")
            }
            if (pin.pulldown) {
              writer.println(s"set_property PULLDOWN TRUE [get_ports ${pin.port}]")
            }
            pin.drive.foreach { d =>
              writer.println(s"set_property DRIVE $d [get_ports ${pin.port}]")
            }
            pin.slew.foreach { s =>
              writer.println(s"set_property SLEW $s [get_ports ${pin.port}]")
            }
          }
          writer.println()
        }
      }
      
    } finally {
      writer.close()
    }
  }
  
  /**
   * Generate TCL build script
   */
  private def generateTclScript(moduleName: String, board: String, targetDir: String): Unit = {
    val tclFile = s"$targetDir/build_$moduleName.tcl"
    val writer = new PrintWriter(tclFile)
    
    val fpgaPart = board match {
      case "au" => "xc7a35tftg256-1"
      case "cu" => "xc7a35tftg256-1"  // Update for Cu
      case _ => "xc7a35tftg256-1"
    }
    
    try {
      writer.println(s"""# Build script for $moduleName
# Board: Alchitry ${board.toUpperCase}

# Create project
create_project $moduleName . -part $fpgaPart -force

# Add sources
add_files $moduleName.sv
add_files -fileset constrs_1 $moduleName.xdc

# Set top module
set_property top $moduleName [current_fileset]

# Run synthesis
launch_runs synth_1 -jobs 4
wait_on_run synth_1

# Run implementation
launch_runs impl_1 -jobs 4
wait_on_run impl_1

# Generate bitstream
launch_runs impl_1 -to_step write_bitstream -jobs 4
wait_on_run impl_1

puts "Build complete!"
""")
    } finally {
      writer.close()
    }
  }
  
  /**
   * Generate human-readable pin report
   */
  private def generatePinReport(pinMappings: Seq[PinMapping], board: String, outputFile: String): Unit = {
    val writer = new PrintWriter(outputFile)
    
    try {
      writer.println(s"Pin Mapping Report for Alchitry ${board.toUpperCase}")
      writer.println("=" * 70)
      writer.println(f"${"Port Name"}%-30s ${"Virtual Pin"}%-15s ${"Real Pin"}%-15s ${"IO Standard"}%-15s")
      writer.println("-" * 70)
      
      pinMappings.sortBy(_.port).foreach { pin =>
        val realPin = AlchitryPinMapper.getRealPin(pin.virtualPin, board)
        writer.println(f"${pin.port}%-30s ${pin.virtualPin}%-15s ${realPin}%-15s ${pin.ioStandard}%-15s")
      }
      
      writer.println()
      writer.println(s"Total pins mapped: ${pinMappings.size}")
      
    } finally {
      writer.close()
    }
  }
}

/**
 * Example usage
 */
object ExampleElaboration extends App {
  import AlchitryElaborator._
  
  // Define pin mappings
  val pinMappings = Seq(
    PinMapping("io_clk", "CLOCK"),
    PinMapping("io_rst_n", "RESET"),
    PinMapping("io_addr[19]", "C49", pullup = true),
    PinMapping("io_addr[18]", "C6", pullup = true),
    PinMapping("io_data[0]", "C40", pullup = true),
    PinMapping("io_data[1]", "C42", pullup = true),
    PinMapping("io_conn_rw", "C46", pullup = true),
    PinMapping("io_conn_oe", "C48", pullup = true)
  )
  
  // Example usage - replace ExampleModule with your actual module
  // AlchitryElaborator.elaborate(
  //   gen = new YourModule,
  //   pinMappings = pinMappings,
  //   board = "au",
  //   targetDir = "build/alchitry"
  // )
}