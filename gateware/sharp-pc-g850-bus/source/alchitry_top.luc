module alchitry_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led[8],          // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output

    // Ft Element
    input ft_clk,
    input ft_rxf,
    input ft_txe,
    inout ft_data[16],
    inout ft_be[2],
    output ft_rd,
    output ft_wr,
    output ft_oe,

    output saleae[8],

    // PC-G850 System Bus
    input z80_mreq,
    input z80_m1,
    input z80_ioreset,
    input z80_iorq,
    input z80_int1,
    input z80_wait,
    input z80_rd,
    input z80_wr,

    input data[8],
    input addr[16],

    input addr_bnk[2],
    input addr_ceram2,
    input addr_cerom2
) {
    sig rst

    enum FtStates {GET_FIFO, STREAM}
    enum SaleaeStates {SYNC_SIGNALS, RAW_SIGNALS, DATA_SIGNALS, BUS_EVENTS, EDGE_SIGNALS, COUNTER}

    sig z80_mreq_sync
    sig z80_m1_sync
    sig z80_iorq_sync
    sig z80_rd_sync
    sig z80_wr_sync
    sig addr_sync[16]
    sig data_sync[8]

    sig mreq_fall
    sig iorq_fall
    sig rd_rise
    sig wr_rise

    .clk(clk) {
        reset_conditioner reset_cond

        // Fix potential metastability issues with pipelines.
        // Make MREQ/IORQ/M1 longer to propagate as we don't want them to rise
        // before RD/WR, so we can check the specifics.
        //
        // NOTE: Delays are likely specific to PC-G850 and 100MHz FPGA clock,
        //       need to verify this assumption using logic analyzer.
        #DEPTH(4) {
            pipeline sync_mreq (.in(z80_mreq))
            pipeline sync_m1   (.in(z80_m1))
            pipeline sync_iorq (.in(z80_iorq))
        }
        #DEPTH(2) {
            pipeline sync_rd   (.in(z80_rd))
            // raw WR get high a few ns before IORQ
            // with 2-pipeline they frequently go up at same exact time,
            // but sometimes the difference is 12ns
            pipeline sync_wr   (.in(z80_wr))

            pipeline sync_addr[16] (.in(addr))
            pipeline sync_data[8]  (.in(data))
        }

        // FIXME: create a test bench for the edge_detector and report a bug
        // because it seems to report the opposite of what it's supposed to do.
        //
        // Seems to be related to the pipeline depth somehow?
        edge_detector mreq_edge(#RISE(0), #FALL(1), .in(z80_mreq_sync)) // want fall
        edge_detector iorq_edge(#RISE(0), #FALL(1), .in(z80_iorq_sync)) // want fall

        edge_detector rd_edge  (#RISE(1), #FALL(0), .in(z80_rd_sync))   // want rise
        edge_detector wr_edge  (#RISE(1), #FALL(0), .in(z80_wr_sync))   // want rise

        .rst(rst) {
            #BAUD(1_000_000), #CLK_FREQ(100_000_000) {
                uart_tx tx
                uart_rx rx
            }

            fifo fifo(#WIDTH(32), #ENTRIES(32768))
            dff fifo_full_counter[24] // 8 bytes for the Err code

            ft ft(#BUS_WIDTH(16), #TX_BUFFER(8192), .ft_clk(ft_clk), .ft_rxf(ft_rxf), .ft_txe(ft_txe), .ft_data(ft_data), .ft_be(ft_be))

            dff ft_enabled
            dff ft_cur_value[32]
            dff ft_state[$width(FtStates)]

            dff saleae_state[$width(SaleaeStates)]
            dff saleae_counter[8]

            dff last_addr[16]
            // `data` is supposed to be valid when both WR/RD go up
            // dff last_data[8]
        }
    }

    sig saleae_rw[4]

    always {
        reset_cond.in = ~rst_n  // input raw inverted reset signal
        rst = reset_cond.out    // conditioned reset

        led = c{ft.ui_din_full, !ft.ui_dout_empty, !ft_rxf, !ft_txe,
                1b0, fifo.full, fifo.empty, ft_enabled.q}
        saleae_rw = 4h00

        usb_tx = tx.tx
        rx.rx = usb_rx
        tx.block = 0
        tx.data = 8h00
        tx.new_data = 0

        // fifo write
        fifo.wput = 0
        fifo.din = 8h00

        // fifo read
        fifo.rget = 0

        ft_rd = ft.ft_rd
        ft_wr = ft.ft_wr
        ft_oe = ft.ft_oe
        ft.ui_din = 0
        ft.ui_din_be = 0
        ft.ui_din_valid = 0
        ft.ui_dout_get = 0

        z80_mreq_sync = sync_mreq.out
        z80_m1_sync = sync_m1.out
        z80_iorq_sync = sync_iorq.out
        z80_rd_sync = sync_rd.out
        z80_wr_sync = sync_wr.out
        addr_sync = sync_addr.out
        data_sync = sync_data.out

        mreq_fall = mreq_edge.out
        iorq_fall = iorq_edge.out
        rd_rise = rd_edge.out
        wr_rise = wr_edge.out

        case (ft_state.q) {
            FtStates.GET_FIFO:
                if (!fifo.empty) {
                    if (!ft.ui_din_full) {
                        fifo.rget = 1

                        ft_cur_value.d = fifo.dout
                        ft.ui_din = fifo.dout[0+:16]
                        ft.ui_din_be = b11
                        ft.ui_din_valid = 1

                        ft_state.d = FtStates.STREAM
                    }
                }

            FtStates.STREAM:
                if (!ft.ui_din_full) {
                    fifo.rget = 1

                    ft.ui_din = ft_cur_value.q[16+:16]
                    ft.ui_din_be = b11
                    ft.ui_din_valid = 1

                    ft_state.d = FtStates.GET_FIFO
                }
        }

        // Synchronize and capture bus address at the start of a bus cycle.
        // Latch the address when either mreq or iorq goes active (falling edge).
        if (mreq_fall || iorq_fall) {
            last_addr.d = addr_sync
        }

        if (rd_rise) {
            if ((z80_mreq_sync && z80_iorq_sync) || (!z80_mreq_sync && !z80_iorq_sync)) {
                tx.new_data = 1
                tx.data = "E"
            } else if (!z80_m1_sync) {
                // M1: Instruction fetch (m1 is active low)
                saleae_rw = b11
                if (ft_enabled.q) {
                    if (!fifo.full) {
                        fifo.wput = 1
                        fifo.din = c{last_addr.q, data_sync, "M"}
                    } else {
                        fifo_full_counter.d = fifo_full_counter.q + 1
                        tx.new_data = 1
                        tx.data = "M"
                    }
                }
            } else if (!z80_mreq_sync) {
                // Memory read event (mreq is active low)
                saleae_rw = b1
                if (ft_enabled.q) {
                    if (!fifo.full) {
                        fifo.wput = 1
                        fifo.din = c{last_addr.q, data_sync, "R"}
                    } else {
                        fifo_full_counter.d = fifo_full_counter.q + 1
                        tx.new_data = 1
                        tx.data = "R"
                    }
                }
            } else if (!z80_iorq_sync) {
                // I/O read event (iorq is active low)
                saleae_rw = b100
                if (ft_enabled.q) {
                    if (!fifo.full) {
                        fifo.wput = 1
                        fifo.din = c{last_addr.q, data_sync, "r"}
                    } else {
                        fifo_full_counter.d = fifo_full_counter.q + 1
                        tx.new_data = 1
                        tx.data = "r"
                    }
                }
            }
        } else if (wr_rise) {
            if ((z80_mreq_sync && z80_iorq_sync) || (!z80_mreq_sync && !z80_iorq_sync)) {
                tx.new_data = 1
                tx.data = "e"
            } else if (!z80_mreq_sync) {
                // Memory write event (mreq is active low)
                saleae_rw = b10
                if (ft_enabled.q) {
                    if (!fifo.full) {
                        fifo.wput = 1
                        fifo.din = c{last_addr.q, data_sync, "W"}
                    } else {
                        fifo_full_counter.d = fifo_full_counter.q + 1
                        tx.new_data = 1
                        tx.data = "W"
                    }
                }
            } else if (!z80_iorq_sync) {
                // I/O write event (iorq is active low)
                saleae_rw = b1000
                if (ft_enabled.q) {
                    if (!fifo.full) {
                        fifo.wput = 1
                        fifo.din = c{last_addr.q, data_sync, "w"}
                    } else {
                        fifo_full_counter.d = fifo_full_counter.q + 1
                        tx.new_data = 1
                        tx.data = "w"
                    }
                }
            }
        } else if (ft_enabled.q && !fifo.full && fifo_full_counter.q > 0) {
            fifo.wput = 1
            fifo.din = c{fifo_full_counter.q, "E"}
            fifo_full_counter.d = 0
        }

        if (rx.new_data) {
            if (rx.data == "1") {
                ft_enabled.d = 1 // enable decoded bus streaming
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "+"
                }
            } else if (rx.data == "0") {
                ft_enabled.d = 0 // disable decoded bus streaming
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "-"
                }
            } else if (rx.data == "s") {
                saleae_state.d = SaleaeStates.SYNC_SIGNALS
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "s"
                }
            } else if (rx.data == "e") {
                saleae_state.d = SaleaeStates.EDGE_SIGNALS
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "e"
                }
            } else if (rx.data == "d") {
                saleae_state.d = SaleaeStates.DATA_SIGNALS
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "d"
                }
            } else if (rx.data == "r") {
                saleae_state.d = SaleaeStates.RAW_SIGNALS
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "r"
                }
            } else if (rx.data == "b") {
                saleae_state.d = SaleaeStates.BUS_EVENTS
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "b"
                }
            } else if (rx.data == "c") {
                saleae_state.d = SaleaeStates.COUNTER
                if (!tx.busy) {
                    tx.new_data = 1
                    tx.data = "c"
                }
            }
        }

        case (saleae_state.q) {
            // check the relative timing of the WR/RD/M1 vs MREQ/IORQ
            // NOTE: edge signals are delayed by ~4ns
            SaleaeStates.SYNC_SIGNALS:
                saleae = c{z80_mreq_sync, z80_iorq_sync, z80_rd_sync, z80_wr_sync,
                           z80_m1_sync, mreq_fall, rd_rise, wr_rise}

            // are fall/rise edges correctly handled?
            SaleaeStates.EDGE_SIGNALS:
                saleae = c{z80_mreq_sync, z80_iorq_sync, z80_rd_sync, z80_wr_sync,
                           mreq_fall, iorq_fall, rd_rise, wr_rise}

            // are we saving last_addr / last_data at the correct time?
            SaleaeStates.DATA_SIGNALS:
                saleae = c{1b0, 1b0, 1b0, 1b0,
                           mreq_fall, iorq_fall, rd_rise, wr_rise}

            // are pipelines really improving the metastability?
            SaleaeStates.RAW_SIGNALS:
                saleae = c{z80_mreq_sync, z80_iorq_sync, z80_rd_sync, z80_wr_sync,
                           z80_mreq, z80_iorq, z80_rd, z80_wr}

            // get decoded events (and extra signals) on the logic analyzer pins
            SaleaeStates.BUS_EVENTS:
                saleae = c{z80_ioreset, z80_wait, z80_int1, z80_m1, saleae_rw}

            // check that pins are read in the correct order
            SaleaeStates.COUNTER:
                saleae = saleae_counter.q
                saleae_counter.d = saleae_counter.q + 1

            default:
                saleae = 0
        }
    }
}
