; Generated by JITX 3.25.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import helpers
  import jsl
  import collections

  ; gen-testpad
  import ocdb/utils/generic-components
  ; get-time-string
  import utils/time


val board-shape = RoundedRectangle(
  components/AlchitryAu/element_width,
  components/AlchitryAu/element_height + 0.0, 3.0)

defstruct Conn :
  start_index : Int
  shifter_index : Int
  invert_shifter_index : True|False
  fpga_port : JITXObject
  shifter_start_index : Int
  fpga_pins : Vector<Int>

pcb-module alchitry-level-shifter :
  inst fpga : components/AlchitryAu/alchitry_element_bottom
  place(fpga) at loc(0.0, 0.0, 0.0) on Top

  ; NOTE: adapter boards need to be flipped to match the pinout.
  inst ffc1 : components/FFCConnector/module(flip_pins = false)
  inst ffc2 : components/FFCConnector/module(flip_pins = false)

  port gnd
  port vcc3v3
  port vcc5v
  net GND (gnd fpga.GND ffc1.GND ffc2.GND)
  net VCC3V3 (vcc3v3 fpga.VCC3V3)
  net VCC5V (vcc5v ffc1.VCC5V ffc2.VCC5V)

  inst saleae : components/Saleae/saleae8

  val num_shifters = 6
  inst shift : components/LevelShifter/module[num_shifters]
  for i in 0 to num_shifters do:
    net (gnd shift[i].gnd)
    net (vcc5v shift[i].vcchi)
    net (vcc3v3 shift[i].vcclo)
    net (vcc3v3 shift[i].oe)

  for i in 0 to 48 :
    net (ffc1.data[i] ffc2.data[i])

  symbol(GND) = GND-SYMB
  symbol(VCC3V3) = PWR-SYMB
  symbol(VCC5V) = PWR-SYMB

  defn do-shift (shiftno:Int, pinno:Int, high:JITXObject, low:JITXObject) :
    ; println(to-string(ref(high)))
    var low-name = replace(to-string(ref(high)), "ffc1.data", "loDATA") as String
    low-name = replace(low-name, "[", "")
    low-name = replace(low-name, "]", "")
    net (high shift[shiftno].PT[pinno].B)
    make-net(to-symbol(low-name), [low, shift[shiftno].PT[pinno].A])

  defn gen-seq (start:Int) :
    val seq = Vector<Int>()
    for i in 0 to 8 :
      add(seq, start + i)
    seq

  ; println(gen-seq(0))
  ; println(gen-seq(8)[1])

  ; pins are arranged in a way to make single-layer layout possible since both
  ; level shifters and FPGA are agnostic, and we just need to keep track of the
  ; resulting pin destination to map it in gateware.
  val conversion = [
    Conn(0,  0, false, fpga.data_a, 0, to-vector<Int>(to-seq([1 3 5 7 0 2 4 6]))),
    Conn(8,  4, true,  fpga.data_c, 0, to-vector<Int>(to-seq([0 2 4 6 1 3 5 7]))),
    Conn(16, 1, false, fpga.data_a, 0, to-vector<Int>(to-seq([8 10 12 14 16 18 22 23]))),
    Conn(24, 2, true,  fpga.data_c, 0, to-vector<Int>(to-seq([9 11 13 15 17 19 21 23]))),
    Conn(40, 3, true,  fpga.data_c, 0, to-vector<Int>(to-seq([25 27 29 31]))),
    Conn(44, 3, true,  fpga.data_d, 4, to-vector<Int>(to-seq([0 2 1 3]))),
    Conn(32, 5, false, fpga.data_a, 0, to-vector<Int>(to-seq([20 21])))
    Conn(34, 5, false, fpga.data_b, 2, to-vector<Int>(to-seq([1 3 0 2 4 6])))
  ]

  net (gnd saleae.gnd)
  net (saleae.data[0], fpga.data_b[15])
  net (saleae.data[1], fpga.data_b[13])
  net (saleae.data[2], fpga.data_b[12])
  net (saleae.data[3], fpga.data_b[14])
  net (saleae.data[4], fpga.data_b[10])
  net (saleae.data[5], fpga.data_b[8])
  net (saleae.data[6], fpga.data_d[4])
  net (saleae.data[7], fpga.data_d[5])

  for i in conversion :
    val start_index = start_index(i)
    val shifter_index = shifter_index(i)
    val fpga_port = fpga_port(i)

    for j in 0 to length(fpga_pins(i)) do :
      val data_index = start_index + j
      val fpga_index = fpga_pins(i)[j]
      val shifter_pin = if invert_shifter_index(i) :
        7 - j - shifter_start_index(i)
      else :
        j + shifter_start_index(i)
      ; println(data_index)
      do-shift(shifter_index, shifter_pin, ffc1.data[data_index], fpga_port[fpga_index])

  val shifter_pos = [
    loc(14.734, 9.4680, 270.0), ; 0
    loc(4.8113, 9.4680, 270.0), ; 1
    loc(0.3, -9.4680, 90.0), ; 2
    loc(-9.2, -9.4680, 90.0), ; 3
    loc(9.8165, -9.4680, 90.0), ; 4
    loc(-7.0, 9.4680, 270.0) ; 5
  ]
  for (myloc in shifter_pos, i in 0 to false) :
    place(shift[i]) at myloc on Top

  ; Test Probes to measure signal integrity for the potential reflections.
  inst tp_hi : gen-testpad(1.0)
  net (tp_hi.p shift[0].PT[0].B)
  inst tp_lo : gen-testpad(1.0)
  net (tp_lo.p shift[0].PT[0].A)
  place(tp_hi) at loc( 4.2, 4.0, 0.0) on Bottom (relative-to shift[0])
  place(tp_lo) at loc(-4.2, 4.0, 0.0) on Bottom (relative-to shift[0])

  val w = width(board-shape)
  val h = height(board-shape)
  inst tp-gnd : components/GndTestpads/module(diameter = 3.0, width = w, height = h)
  net (tp-gnd.GND GND)
  place(tp-gnd) at loc(0.0, 0.0) on Top

  inst tp_vcc : gen-testpad(1.0)[2]
  net (vcc3v3 tp_vcc[0].p)
  net (vcc5v  tp_vcc[1].p)
  place(tp_vcc[0]) at loc(0.0, 12.0) on Bottom
  place(tp_vcc[1]) at loc(0.0, 7.0)  on Bottom

  val ffc_distance = components/FFCConnector/ffc-height + 2.0
  val ffc_offset_y = 0.75
  place(ffc1) at loc(2.3960, ffc_offset_y + ffc_distance / -2.0, 180.0) on Bottom
  place(ffc2) at loc(2.3960, ffc_offset_y + ffc_distance / 2.0, 180.0) on Bottom

  val mydate:String = get-time-string("%Y-%m-%d")
  inst name-label : ocdb/artwork/board-text/text("Level Shifter Element v1", 1.5, 0.0)
  inst version-label  : ocdb/artwork/board-text/text(append("(c) mblsha ", mydate), 1.5, 0.0)
  place(name-label)    at loc(w / 2.0 - 5.0, 0.0, 90.0) on Bottom
  place(version-label) at loc(w / 2.0 - 3.0, 0.0, 90.0) on Bottom

  place(saleae) at loc(w / -2.0 + 10.0, 0.0, 0.0) on Bottom

  ; NOTE: bgupta recommended commenting out the copper-pours during the initial
  ;       layout phase to help avoid major slowdowns.

  ; geom(GND) :
  ;   copper-pour(LayerIndex(0),         isolate = 0.15, rank = 1) = board-shape
  ;   copper-pour(LayerIndex(1),         isolate = 0.15, rank = 1) = board-shape
  ;   copper-pour(LayerIndex(0, Bottom), isolate = 0.15, rank = 1) = board-shape
  ; geom(VCC3V3) :
  ;   copper-pour(LayerIndex(2),         isolate = 0.15, rank = 1) = board-shape


; Set the :
;     design-name     - a directory with this name will be created in the "designs" directory
;     board           - a Board object representing the stackup, rules and board shape for a particular design
;     signal-shrink   - a distance in mm to pull back copper signals from the board edge
setup-design("alchitry-level-shifter", board-shape, signal-shrink = 0.5)

set-main-module(alchitry-level-shifter)

; view-bom(BOM-STD)
view-schematic()
view-board()

; export-to-cad()


